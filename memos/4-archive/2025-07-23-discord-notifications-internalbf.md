# Discord Notifications via InternalBF Implementation Memo

## Overview

Set up GitHub notifications (deployments, PR events) that get sent to Discord
via our internalbf service deployed to internalbf.com. This creates a
centralized notification system using our existing Discord bot infrastructure.

## Architecture

- **GitHub Webhooks** ‚Üí **internalbf.com/webhooks/github** ‚Üí **Discord via
  existing bot**
- **Single webhook endpoint** handles all GitHub events and routes internally
- **Host-based routing** via Kamal on same Hetzner server as boltfoundry-com
- **Separate domain** (internalbf.com) for clean service separation

## Implementation Steps

### 1. Deploy internalbf to Hetzner

#### Infrastructure Changes

- [ ] Add DNS record for internalbf.com pointing to same server IP
- [ ] Create Kamal config template for internalbf deployment
- [ ] Update Terraform to generate both deploy configs
- [ ] Create Dockerfile for internalbf binary

#### Deployment

- [ ] Create GitHub workflow for internalbf deployment
- [ ] Configure Kamal secrets for Discord bot tokens
- [ ] Test deployment to ensure internalbf.com resolves correctly

### 2. GitHub Webhook Configuration

#### Webhook Endpoint

- [x] Add URLPattern-based routing to internalbf
- [x] Create `/webhooks/github` endpoint that handles all GitHub events
- [x] Route events based on `x-github-event` header:
  - `workflow_run` ‚Üí deployment notifications
  - `pull_request` ‚Üí PR merge notifications
  - `pull_request_review` ‚Üí review request notifications

#### Event Filtering

- **Repository**: Only accept events from `bolt-foundry/bolt-foundry` repository
- **Deployments**: All completed deployment workflows (detected by workflow
  characteristics)
- **PRs**: Only merged pull requests
- **Reviews**: Only review_requested actions

### 3. Discord Integration

#### Configuration

- [x] Reuse existing Discord client from ThanksBot
- [ ] Add `DISCORD_NOTIFICATIONS_CHANNEL_ID` environment variable
- [x] Send formatted messages to designated channel

#### Message Formats

```
‚úÖ **Deployment succeeded**
**Workflow:** Deploy boltfoundry-com
**Repository:** bolt-foundry/bolt-foundry
**Branch:** main
**Commit:** abc1234
**URL:** https://github.com/...

üéâ **Pull Request Merged**
**Title:** Add new feature
**Repository:** bolt-foundry/bolt-foundry
**Author:** username
**Merged by:** username
**URL:** https://github.com/...

üëÄ **Review Requested**
**Title:** Fix bug in component
**Repository:** bolt-foundry/bolt-foundry
**Author:** username
**Reviewer:** username
**URL:** https://github.com/...
```

### 4. GitHub Repository Configuration

#### Webhook Setup

- [ ] Add webhook in GitHub repo settings:
  - **URL**: `https://internalbf.com/webhooks/github`
  - **Events**: workflow_run, pull_request, pull_request_review
  - **Content-Type**: application/json

#### Secrets Required

- [ ] `DISCORD_NOTIFICATIONS_CHANNEL_ID` - Discord channel ID for notifications
- [ ] `THANKSBOT_TOKEN` - Discord bot token (reused)
- [ ] `THANKSBOT_NOTION_TOKEN` - Notion integration (existing)
- [ ] `THANKSBOT_NOTION_DATABASE_ID` - Notion database (existing)

### 5. Remove Old Notification System

#### Clean up deploy-boltfoundry-com.yml

- [ ] Remove old echo-based notification steps
- [ ] Deployment notifications now handled via GitHub webhook to internalbf

## File Changes Needed

### New Files Required

```
apps/internalbf/Dockerfile - Need to create simple Deno runtime container
infra/terraform/hetzner/deploy-internalbf.yml.tpl - Need to create Kamal config template
config/deploy-internalbf.yml - Will be generated by Terraform (directory needs creation)
.github/workflows/deploy-internalbf.yml - Need to create deployment workflow
```

### Modified Files Required

```
infra/terraform/hetzner/main.tf - Need to add internalbf.com DNS and Kamal config generation
```

### Existing Files (Already Complete)

```
apps/internalbf/internalbf.ts - ‚úÖ Already has webhook routing and Discord integration
```

## Deployment Commands

### Initial Setup (After Creating Required Files)

```bash
# 1. First create all required files (see File Changes Needed section above)

# 2. Deploy infrastructure (adds DNS record) 
cd infra/terraform/hetzner
terraform apply

# 3. Deploy internalbf service
git push origin main  # Will trigger deploy-internalbf.yml workflow once created
```

### Current Status

- ‚ö†Ô∏è **Cannot deploy yet** - Required files don't exist (see File Changes
  Needed)
- internalbf.com currently redirects to Replit instead of Hetzner server

### Verification

```bash
# Test webhook endpoint
curl -X POST https://internalbf.com/webhooks/github \
  -H "Content-Type: application/json" \
  -H "X-GitHub-Event: ping" \
  -d '{"zen":"GitHub is awesome"}'

# Check Discord bot status
curl https://internalbf.com/
```

## Configuration Requirements

### GitHub Repository Webhook

- **URL**: `https://internalbf.com/webhooks/github`
- **Content type**: `application/json`
- **Events**:
  - Workflow runs
  - Pull requests
  - Pull request reviews
- **Active**: ‚úì

### Discord Channel Setup

- [ ] Create dedicated notifications channel
- [ ] Get channel ID and add to GitHub secrets as
      `DISCORD_NOTIFICATIONS_CHANNEL_ID`
- [ ] Ensure bot has permission to send messages to channel

### Environment Variables

```bash
# Production (set in Kamal secrets)
DISCORD_NOTIFICATIONS_CHANNEL_ID=123456789  # Discord channel ID
THANKSBOT_TOKEN=...                          # Discord bot token
THANKSBOT_NOTION_TOKEN=...                   # Existing Notion integration
THANKSBOT_NOTION_DATABASE_ID=...             # Existing Notion database
```

## Benefits

1. **Centralized**: All GitHub notifications go through one service
2. **Extensible**: Easy to add new event types or notification channels
3. **Reliable**: Uses existing Discord bot infrastructure
4. **Clean**: Separate domain for service separation
5. **Maintainable**: Single webhook URL to manage

## Testing Checklist

### Prerequisites (Must Complete First)

- [ ] Create all required files (see File Changes Needed section)
- [ ] Deploy internalbf service to Hetzner (currently redirects to Replit)
- [ ] Configure GitHub webhook in bolt-foundry/bolt-foundry repository
- [ ] Set up Discord channel and configure secrets

### Service Testing

- [ ] Verify internalbf.com resolves to server IP (currently fails - redirects
      to Replit)
- [ ] Test webhook endpoint responds to POST requests
- [ ] Verify Discord bot can send messages to notifications channel

### Integration Testing

- [ ] Test deployment notifications (trigger a deployment)
- [ ] Test PR notifications (merge a test PR)
- [ ] Test review request notifications (request review on test PR)
- [ ] Verify webhook shows up in GitHub delivery logs

### Current Status

- ‚ö†Ô∏è **Cannot test yet** - Service not properly deployed
- ‚ö†Ô∏è **No GitHub webhooks configured** - None exist in bolt-foundry/bolt-foundry
  repo

## Troubleshooting

### Common Issues

1. **DNS not resolving**: Check Cloudflare DNS record exists and is proxied
2. **Webhook timeouts**: Verify internalbf service is running on port 9999
3. **Discord messages not sending**: Check bot token and channel ID are correct
4. **404 on webhook**: Verify URLPattern routing is working correctly

### Debug Commands

```bash
# Check service status
kamal app logs -c config/deploy-internalbf.yml

# Test DNS resolution
nslookup internalbf.com

# Check server routing
curl -v https://internalbf.com/

# Test webhook locally
curl -X POST http://localhost:9999/webhooks/github \
  -H "Content-Type: application/json" \
  -H "X-GitHub-Event: ping" \
  -d '{"zen":"test"}'
```

## Future Enhancements

- [ ] Add webhook signature verification for security
- [ ] Support for more GitHub event types (issues, releases, etc.)
- [ ] Multiple Discord channels for different event types
- [ ] Slack integration using same webhook system
- [ ] Rate limiting for webhook endpoints
- [ ] Metrics/monitoring for notification delivery

## Appendix: Related Files

### A. Dockerfile for InternalBF

**File:** `apps/internalbf/Dockerfile`

```dockerfile
FROM debian:12-slim

# Install minimal runtime dependencies
RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Copy the compiled binary
COPY build/internalbf /usr/local/bin/internalbf
RUN chmod +x /usr/local/bin/internalbf

# Non-root user for security
RUN useradd -r -s /bin/false app
USER app

EXPOSE 9999

CMD ["/usr/local/bin/internalbf"]
```

### B. Kamal Configuration Template

**File:** `infra/terraform/hetzner/deploy-internalbf.yml.tpl`

```yaml
service: internalbf

image: internalbf

servers:
  web:
    - ${floating_ip}

# SSL via Let's Encrypt
ssl:
  email: support@boltfoundry.com

registry:
  # Use GitHub Container Registry
  server: ghcr.io
  username: ${github_username}
  password:
    - GITHUB_TOKEN

env:
  clear:
    PORT: 9999
    BF_ENV: production
  secret:
    - THANKSBOT_TOKEN
    - THANKSBOT_NOTION_TOKEN
    - THANKSBOT_NOTION_DATABASE_ID
    - DISCORD_NOTIFICATIONS_CHANNEL_ID

aliases:
  console: app exec --interactive --reuse "bash"
  shell: app exec --interactive --reuse "bash"
  logs: app logs --follow

# Health check
healthcheck:
  path: /
  port: 9999
  max_attempts: 7

# Different port to avoid conflicts with boltfoundry-com
traefik:
  options:
    publish:
      - "9999:9999"
```

### C. Terraform Changes Needed

**File:** `infra/terraform/hetzner/main.tf` - Add DNS record:

```hcl
# Cloudflare DNS record for internalbf.com
resource "cloudflare_record" "internalbf" {
  zone_id = var.cloudflare_zone_id
  name    = "internalbf.com"
  value   = hcloud_floating_ip.web.ip_address
  type    = "A"
  ttl     = 1  # Auto TTL
  proxied = true  # Enable Cloudflare proxy for SSL termination and protection
}

# Generate Kamal config for internalbf
resource "local_file" "kamal_config_internalbf" {
  content = templatefile("${path.module}/deploy-internalbf.yml.tpl", {
    floating_ip     = hcloud_floating_ip.web.ip_address
    github_username = var.github_username
  })
  filename = "${path.module}/../../../config/deploy-internalbf.yml"
}
```

### D. Kamal Multi-Service Routing Research

**How Kamal Handles Multiple Services on Same Server:**

Kamal 2.x uses **domain-based routing** (not port-based) through either
`kamal-proxy` or Traefik:

1. **Internal Container Ports**: Each service runs on its own port inside
   containers
   - boltfoundry-com: port 8000
   - internalbf: port 9999 ‚úÖ (no conflicts)

2. **External Routing**: Reverse proxy routes by domain to internal container
   ports
   - `boltfoundry.com` ‚Üí container on port 8000
   - `internalbf.com` ‚Üí container on port 9999

3. **SSL Management**: Automatic Let's Encrypt certificates per domain

**Recommended Configuration for internalbf:**

```yaml
# config/deploy-internalbf.yml
service: internalbf
proxy:
  host: internalbf.com # Domain-based routing, not port-based
env:
  clear:
    PORT: 9999 # Internal container port (no conflicts)
healthcheck:
  port: 9999 # Health check on internal port
```

**Key Points:**

- ‚úÖ Port 9999 configuration in memo is correct
- ‚úÖ No additional Traefik configuration needed for basic routing
- ‚úÖ Kamal 2.x handles multi-service deployments natively
- ‚úÖ SSL certificates automatically managed per domain

### E. Core Webhook Handler Logic

**File:** `apps/internalbf/internalbf.ts` - Key webhook handling functions:

```typescript
// Route patterns with URLPattern
const routes = [
  {
    pattern: new URLPattern({ pathname: "/webhooks/github" }),
    method: "POST",
    handler: handleGitHubWebhook,
  },
  {
    pattern: new URLPattern({ pathname: "/" }),
    method: "GET",
    handler: handleHomePage,
  },
];

// GitHub webhook handler
async function handleGitHubWebhook(req: Request): Promise<Response> {
  try {
    const payload = await req.json();
    const eventType = req.headers.get("x-github-event");

    logger.info(`Received GitHub webhook: ${eventType}`);

    if (!client?.isReady()) {
      logger.warn("Discord client not ready, skipping notification");
      return new Response("Discord client not ready", { status: 200 });
    }

    switch (eventType) {
      case "workflow_run":
        return await handleWorkflowRun(payload);
      case "pull_request":
        return await handlePullRequest(payload);
      case "pull_request_review":
        return await handlePullRequestReview(payload);
      default:
        logger.info(`Unhandled GitHub event type: ${eventType}`);
        return new Response("Event type not handled", { status: 200 });
    }
  } catch (error) {
    logger.error("Error handling GitHub webhook:", error);
    return new Response("Webhook processed", { status: 200 });
  }
}

// Handle deployment notifications
async function handleWorkflowRun(payload: any): Promise<Response> {
  const { workflow_run, repository } = payload;

  // Only process events from bolt-foundry/bolt-foundry repository
  if (repository.full_name !== "bolt-foundry/bolt-foundry") {
    return new Response("Repository not monitored", { status: 200 });
  }

  // Only handle completed deployment workflows
  if (workflow_run.status !== "completed") {
    return new Response("Workflow not completed", { status: 200 });
  }

  // Accept all deployment workflows (could filter by name containing "deploy" if needed)
  // This allows flexibility for workflow naming without hardcoded lists

  const success = workflow_run.conclusion === "success";
  const emoji = success ? "‚úÖ" : "‚ùå";
  const status = success ? "succeeded" : "failed";

  const message = `${emoji} **Deployment ${status}**\n` +
    `**Workflow:** ${workflow_run.name}\n` +
    `**Repository:** ${repository.full_name}\n` +
    `**Branch:** ${workflow_run.head_branch}\n` +
    `**Commit:** ${workflow_run.head_sha.substring(0, 7)}\n` +
    `**URL:** ${workflow_run.html_url}`;

  await sendDiscordMessage(message);
  return new Response("Deployment notification sent", { status: 200 });
}

// Send message to Discord via existing bot
async function sendDiscordMessage(message: string): Promise<void> {
  if (!client?.isReady()) {
    logger.warn("Discord client not ready");
    return;
  }

  try {
    const channelId = getConfigurationVariable(
      "DISCORD_NOTIFICATIONS_CHANNEL_ID",
    );
    if (!channelId) {
      logger.error("DISCORD_NOTIFICATIONS_CHANNEL_ID not set");
      return;
    }

    const channel = await client.channels.fetch(channelId);
    if (channel?.isTextBased()) {
      await channel.send(message);
      logger.info("Discord notification sent successfully");
    } else {
      logger.error("Channel is not text-based or not found");
    }
  } catch (error) {
    logger.error("Error sending Discord message:", error);
  }
}
```
