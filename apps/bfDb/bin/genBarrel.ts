#!/usr/bin/env -S deno run --allow-read --allow-write --allow-env

import { relative } from "@std/path";
import { getLogger } from "packages/logger/logger.ts";

const logger = getLogger(import.meta);

/* -------------------------------------------------------------------------- */
/* Config & helper                                                            */
/* -------------------------------------------------------------------------- */

type BarrelConfig = {
  /** Directory to scan (top‑level only) */
  dir: URL;
  /** Where to write the barrel file */
  out: URL;
  /** Function mapping a file name (e.g. "Foo.ts") to its import specifier */
  importPath: (fname: string) => string;
  /** Optional banner (defaults to the std. banner) */
  banner?: string;
};

const DEFAULT_BANNER =
  "/* @generated */\n/* This file is auto-generated by generateBarrels.ts. */";

/** Shared code‑gen helper – renders the barrel file and writes it. */
async function generateBarrel(cfg: BarrelConfig) {
  const exportLines: string[] = [];

  for await (const entry of Deno.readDir(cfg.dir)) {
    if (!entry.isFile || !entry.name.endsWith(".ts")) continue;
    if (entry.name.startsWith("_")) continue; // private helpers
    if (entry.name === "__generated__") continue; // skip gen dir itself
    exportLines.push(`export * from \"${cfg.importPath(entry.name)}\";`);
  }

  exportLines.sort(); // deterministic diff‑friendly order

  const banner = cfg.banner ?? DEFAULT_BANNER;
  const content = `${banner}\n\n${exportLines.join("\n")}\n`;

  await Deno.mkdir(new URL("./", cfg.out), { recursive: true });
  await Deno.writeTextFile(cfg.out, content);

  logger.info(
    `✅  wrote ${
      relative(Deno.cwd(), cfg.out.pathname)
    } (⟶ ${exportLines.length} exports)`,
  );
}

/* -------------------------------------------------------------------------- */
/* Barrel definitions                                                          */
/* -------------------------------------------------------------------------- */

const barrels: BarrelConfig[] = [
  // 1️⃣  Models
  {
    dir: new URL("../models/", import.meta.url),
    out: new URL(
      "../models/__generated__/modelClassesList.ts",
      import.meta.url,
    ),
    importPath: (f) => `apps/bfDb/models/${f}`,
  },
  // 2️⃣  Core Models
  {
    dir: new URL("../coreModels/", import.meta.url),
    out: new URL(
      "../coreModels/__generated__/coreModelClassesList.ts",
      import.meta.url,
    ),
    importPath: (f) => `apps/bfDb/coreModels/${f}`,
  },
  // 3️⃣  Top‑level classes (utility / abstract classes)
  {
    dir: new URL("../classes/", import.meta.url),
    out: new URL("../classes/__generated__/classesList.ts", import.meta.url),
    importPath: (f) => `apps/bfDb/classes/${f}`,
  },
  // 4️⃣  GraphQL root objects (AuthRoot, HealthRoot, …)
  {
    dir: new URL("../graphql/roots/", import.meta.url),
    out: new URL(
      "../graphql/roots/__generated__/rootObjectsList.ts",
      import.meta.url,
    ),
    importPath: (f) => `apps/bfDb/graphql/roots/${f}`,
  },
];

export async function generateAllBarrels() {
  for (const cfg of barrels) {
    await generateBarrel(cfg);
  }
}

/* -------------------------------------------------------------------------- */
/* Kick‑off                                                                    */
/* -------------------------------------------------------------------------- */
if (import.meta.main) {
  await generateAllBarrels();
}

logger.info("✨  Barrel generation complete");
