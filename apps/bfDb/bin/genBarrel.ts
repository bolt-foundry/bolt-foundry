#!/usr/bin/env -S deno run --allow-read --allow-write --allow-env

import { relative } from "@std/path";
import { getLogger } from "packages/logger/logger.ts";

const logger = getLogger(import.meta);

/* -------------------------------------------------------------------------- */
/* Config & helper                                                            */
/* -------------------------------------------------------------------------- */

type BarrelConfig = {
  /** Directory to scan (top‑level only) */
  dir: URL;
  /** Where to write the barrel file */
  out: URL;
  /** Function mapping a file name (e.g. "Foo.ts") to its import specifier */
  importPath: (fname: string) => string;
  /** Optional banner (defaults to the std. banner) */
  banner?: string;
};

const DEFAULT_BANNER =
  "/* @generated */\n/* This file is auto-generated by generateBarrels.ts. */";

/** Shared code‑gen helper – renders the barrel file and writes it. */
async function generateBarrel(cfg: BarrelConfig) {
  const exportLines: string[] = [];

  // Handle GraphQL interfaces barrel file specially
  const isInterfacesBarrel = cfg.out.pathname.includes("interfacesList.ts");

  for await (const entry of Deno.readDir(cfg.dir)) {
    if (!entry.isFile || !entry.name.endsWith(".ts")) continue;
    if (entry.name.startsWith("_")) continue; // private helpers
    if (entry.name === "__generated__") continue; // skip gen dir itself

    // For the interfaces barrel, only include files with @GraphQLInterface decorator
    if (isInterfacesBarrel) {
      const filePath = new URL(entry.name, cfg.dir);
      const content = await Deno.readTextFile(filePath);

      // Check for @GraphQLInterface decorator in the file
      // This works with both @GraphQLInterface() and @GraphQLInterface({...})
      const hasDecorator = content.includes("@GraphQLInterface");

      if (!hasDecorator) {
        continue; // Skip files without the decorator
      }

      logger.debug(`Found GraphQL interface in ${entry.name}`);
    }

    exportLines.push(`export * from \"${cfg.importPath(entry.name)}\";`);
  }

  exportLines.sort(); // deterministic diff‑friendly order

  const banner = cfg.banner ?? DEFAULT_BANNER;
  const content = `${banner}\n\n${exportLines.join("\n")}\n`;

  await Deno.mkdir(new URL("./", cfg.out), { recursive: true });
  await Deno.writeTextFile(cfg.out, content);

  logger.info(
    `✅  wrote ${
      relative(Deno.cwd(), cfg.out.pathname)
    } (⟶ ${exportLines.length} exports)`,
  );
}

/* -------------------------------------------------------------------------- */
/* Barrel definitions                                                          */
/* -------------------------------------------------------------------------- */

const barrels: BarrelConfig[] = [
  // 1️⃣  Models
  {
    dir: new URL("../nodeTypes/", import.meta.url),
    out: new URL(
      "../models/__generated__/nodeTypesList.ts",
      import.meta.url,
    ),
    importPath: (f) => `apps/bfDb/nodeTypes/${f}`,
  },
  // // 2️⃣  Core Models
  // {
  //   dir: new URL("../coreModels/", import.meta.url),
  //   out: new URL(
  //     "../coreModels/__generated__/coreModelClassesList.ts",
  //     import.meta.url,
  //   ),
  //   importPath: (f) => `apps/bfDb/coreModels/${f}`,
  // },
  // 3️⃣  Top‑level classes (utility / abstract classes)
  {
    dir: new URL("../classes/", import.meta.url),
    out: new URL("../classes/__generated__/classesList.ts", import.meta.url),
    importPath: (f) => `apps/bfDb/classes/${f}`,
  },
  // 4️⃣  GraphQL root objects (HealthRoot, …)
  {
    dir: new URL("../graphql/roots/", import.meta.url),
    out: new URL(
      "../graphql/roots/__generated__/rootObjectsList.ts",
      import.meta.url,
    ),
    importPath: (f) => `apps/bfDb/graphql/roots/${f}`,
  },
  // 5️⃣  GraphQL interfaces - scan classes directory for @GraphQLInterface decorators
  {
    dir: new URL("../classes/", import.meta.url),
    out: new URL(
      "../graphql/__generated__/interfacesList.ts",
      import.meta.url,
    ),
    importPath: (f) => `apps/bfDb/classes/${f}`,
    banner: `/**
 * GraphQL Interface Barrel File
 *
 * @generated
 * This file is auto-generated. Do not edit directly.
 *
 * Contains exports of all classes decorated with @GraphQLInterface.
 * These classes will be registered as GraphQL interfaces in the schema.
 */`,
  },
];

export async function generateAllBarrels() {
  for (const cfg of barrels) {
    await generateBarrel(cfg);
  }
}

/* -------------------------------------------------------------------------- */
/* Kick‑off                                                                    */
/* -------------------------------------------------------------------------- */
if (import.meta.main) {
  await generateAllBarrels();
}

logger.info("✨  Barrel generation complete");
