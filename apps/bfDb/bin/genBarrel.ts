#!/usr/bin/env -S deno run --allow-read --allow-write --allow-env

import { relative } from "@std/path";
import { getLogger } from "@bfmono/packages/logger/logger.ts";

const logger = getLogger(import.meta);

/* -------------------------------------------------------------------------- */
/* Config & helper                                                            */
/* -------------------------------------------------------------------------- */

type BarrelConfig = {
  /** Directory to scan (recursively) */
  dir: URL;
  /** Where to write the barrel file */
  out: URL;
  /** Function mapping a file path (e.g. "rlhf/BfDeck.ts") to its import specifier */
  importPath: (fpath: string) => string;
  /** Optional banner (defaults to the std. banner) */
  banner?: string;
};

const DEFAULT_BANNER =
  "/* @generated */\n/* This file is auto-generated by generateBarrels.ts. */";

/** Recursively scan directory for TypeScript files */
async function* scanDirectory(
  dir: URL,
  relativePath = "",
): AsyncGenerator<{ name: string; path: string }> {
  for await (const entry of Deno.readDir(dir)) {
    if (entry.name.startsWith("_")) continue; // private helpers
    if (entry.name === "__generated__") continue; // skip gen dir itself

    if (
      entry.isFile && entry.name.endsWith(".ts") &&
      !entry.name.endsWith(".test.ts")
    ) {
      const fullPath = relativePath
        ? `${relativePath}/${entry.name}`
        : entry.name;
      yield { name: entry.name, path: fullPath };
    } else if (entry.isDirectory) {
      const subDir = new URL(`${entry.name}/`, dir);
      const subPath = relativePath
        ? `${relativePath}/${entry.name}`
        : entry.name;
      yield* scanDirectory(subDir, subPath);
    }
  }
}

/** Shared code‑gen helper – renders the barrel file and writes it. */
async function generateBarrel(cfg: BarrelConfig) {
  const exportLines: Array<string> = [];

  // Handle GraphQL interfaces barrel file specially
  const isInterfacesBarrel = cfg.out.pathname.includes("interfacesList.ts");

  for await (const file of scanDirectory(cfg.dir)) {
    // For the interfaces barrel, only include files with @GraphQLInterface decorator
    if (isInterfacesBarrel) {
      const filePath = new URL(file.path, cfg.dir);
      const content = await Deno.readTextFile(filePath);

      // Check for @GraphQLInterface decorator in the file
      // This works with both @GraphQLInterface() and @GraphQLInterface({...})
      const hasDecorator = content.includes("@GraphQLInterface");

      if (!hasDecorator) {
        continue; // Skip files without the decorator
      }

      logger.debug(`Found GraphQL interface in ${file.path}`);
    }

    exportLines.push(`export * from \"${cfg.importPath(file.path)}\";`);
  }

  exportLines.sort(); // deterministic diff‑friendly order

  const banner = cfg.banner ?? DEFAULT_BANNER;
  const content = `${banner}\n\n${exportLines.join("\n")}\n`;

  await Deno.mkdir(new URL("./", cfg.out), { recursive: true });
  await Deno.writeTextFile(cfg.out, content);

  logger.info(
    `✅  wrote ${
      relative(Deno.cwd(), cfg.out.pathname)
    } (⟶ ${exportLines.length} exports)`,
  );
}

/* -------------------------------------------------------------------------- */
/* Barrel definitions                                                          */
/* -------------------------------------------------------------------------- */

const barrels: Array<BarrelConfig> = [
  // 1️⃣  Models
  {
    dir: new URL("../nodeTypes/", import.meta.url),
    out: new URL(
      "../models/__generated__/nodeTypesList.ts",
      import.meta.url,
    ),
    importPath: (f) => `apps/bfDb/nodeTypes/${f}`,
  },
  // // 2️⃣  Core Models
  // {
  //   dir: new URL("../coreModels/", import.meta.url),
  //   out: new URL(
  //     "../coreModels/__generated__/coreModelClassesList.ts",
  //     import.meta.url,
  //   ),
  //   importPath: (f) => `apps/bfDb/coreModels/${f}`,
  // },
  // 3️⃣  Top‑level classes (utility / abstract classes)
  {
    dir: new URL("../classes/", import.meta.url),
    out: new URL("../classes/__generated__/classesList.ts", import.meta.url),
    importPath: (f) => `apps/bfDb/classes/${f}`,
  },
  // 4️⃣  GraphQL root objects (HealthRoot, …)
  {
    dir: new URL("../graphql/roots/", import.meta.url),
    out: new URL(
      "../graphql/roots/__generated__/rootObjectsList.ts",
      import.meta.url,
    ),
    importPath: (f) => `apps/bfDb/graphql/roots/${f}`,
  },
  // 5️⃣  GraphQL interfaces - scan classes directory for @GraphQLInterface decorators
  {
    dir: new URL("../classes/", import.meta.url),
    out: new URL(
      "../graphql/__generated__/interfacesList.ts",
      import.meta.url,
    ),
    importPath: (f) => `apps/bfDb/classes/${f}`,
    banner: `/**
 * GraphQL Interface Barrel File
 *
 * @generated
 * This file is auto-generated. Do not edit directly.
 *
 * Contains exports of all classes decorated with @GraphQLInterface.
 * These classes will be registered as GraphQL interfaces in the schema.
 */`,
  },
];

export async function generateAllBarrels() {
  for (const cfg of barrels) {
    await generateBarrel(cfg);
  }
}

/* -------------------------------------------------------------------------- */
/* Kick‑off                                                                    */
/* -------------------------------------------------------------------------- */
if (import.meta.main) {
  await generateAllBarrels();
}

logger.info("✨  Barrel generation complete");
