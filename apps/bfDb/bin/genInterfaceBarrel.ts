#!/usr/bin/env -S bff

/**
 * Generates barrel files for GraphQL interfaces
 */

import { walk } from "@std/fs/walk";
import { getLogger } from "packages/logger/logger.ts";
import { dirname, join, relative } from "@std/path";

const logger = getLogger(import.meta);

const WORKSPACE_ROOT = "/home/runner/workspace";
const GRAPHQL_DIR = join(WORKSPACE_ROOT, "apps/bfDb/graphql");
const OUTPUT_PATH = join(GRAPHQL_DIR, "__generated__/graphqlInterfaces.ts");

/**
 * Checks if a class is a GraphQL interface class
 * @param classObj The class constructor to check
 * @returns True if the class is a GraphQL interface
 */
// deno-lint-ignore no-explicit-any
export function isInterfaceClass(classObj: any): boolean {
  // Check if it has a name that matches the interface pattern
  if (!classObj || typeof classObj !== "function") {
    return false;
  }

  // Check if it's the GraphQLNode class or extends it
  if (classObj.name === "GraphQLNode") {
    return true;
  }

  // Check if the class has interface-like traits
  try {
    // Check if the class has "interface" in its name
    if (
      classObj.name.includes("Interface") || classObj.name.endsWith("Interface")
    ) {
      return true;
    }

    // Check if class is abstract
    const prototype = classObj.prototype;
    if (
      prototype && prototype.constructor.toString().includes("abstract class")
    ) {
      return true;
    }

    // Check if it has a gqlSpec static property that defines interface fields
    if (classObj.gqlSpec && classObj.name.includes("GraphQL")) {
      return true;
    }
  } catch (_error) {
    // If any reflection fails, assume it's not an interface
    return false;
  }

  return false;
}

/**
 * Finds all GraphQL interface classes in the codebase
 * @returns Array of file paths to interface classes
 */
export async function findInterfaceClasses(): Promise<string[]> {
  const interfaceFiles: string[] = [];

  // Guaranteed to include the GraphQLNode interface
  interfaceFiles.push(join(GRAPHQL_DIR, "GraphQLNode.ts"));

  // Look for additional interface files
  for await (
    const entry of walk(GRAPHQL_DIR, {
      includeDirs: false,
      exts: [".ts"],
      skip: [/_test\.ts$/, /__tests__/, /__generated__/],
    })
  ) {
    // Skip the GraphQLNode.ts file since we've already added it
    if (entry.path.endsWith("GraphQLNode.ts")) {
      continue;
    }

    // Check if the file contains interface classes
    try {
      const content = await Deno.readTextFile(entry.path);

      // Simple heuristic: file contains "interface" keywords or abstract classes
      if (
        content.includes("abstract class") ||
        content.includes("interface ") ||
        (content.includes("class") && content.includes("GraphQL") &&
          content.includes("Interface"))
      ) {
        // Import the file to check if it contains interface classes
        try {
          const module = await import(`file://${entry.path}`);

          // Check if any exported class is an interface
          for (const [_name, value] of Object.entries(module)) {
            if (isInterfaceClass(value)) {
              interfaceFiles.push(entry.path);
              break;
            }
          }
        } catch (_error) {
          // Skip files that can't be imported
        }
      }
    } catch (_error) {
      // Skip files that can't be read
    }
  }

  return interfaceFiles;
}

/**
 * Generates the interface barrel file
 */
export async function generateInterfaceBarrel(): Promise<void> {
  // Create the output directory if it doesn't exist
  try {
    await Deno.mkdir(dirname(OUTPUT_PATH), { recursive: true });
  } catch (_error) {
    // Directory might already exist, ignore the error
  }

  // Find all interface classes
  const interfaceFiles = await findInterfaceClasses();

  // Generate the barrel file content
  const banner =
    "/* @generated */\n/* This file is auto-generated by genInterfaceBarrel.ts. */";
  const exportLines = interfaceFiles.map((filePath) => {
    // Convert absolute path to import path
    const relativePath = filePath.replace(WORKSPACE_ROOT, "").replace(
      /^\//,
      "",
    );
    return `export * from "${relativePath}";`;
  });

  // Sort for consistent output
  exportLines.sort();

  // Write the barrel file
  const content = `${banner}\n\n${exportLines.join("\n")}\n`;
  await Deno.writeTextFile(OUTPUT_PATH, content);

  logger.info(
    `✅ Wrote ${
      relative(Deno.cwd(), OUTPUT_PATH)
    } (⟶ ${exportLines.length} exports)`,
  );
}

// Run the generator when this file is executed directly
if (import.meta.main) {
  await generateInterfaceBarrel();
}
