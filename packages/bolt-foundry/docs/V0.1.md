# Bolt Foundry SDK v0.1 Implementation Plan

## Overview

Version 0.1 extends the v0.0 generic spec foundation with domain-specific
builders that provide structured, type-safe APIs for common LLM prompt patterns.
These builders leverage the base `Spec` and `SpecBuilder` architecture while
adding semantic meaning and validation.

## Technical Reasoning

### Why Domain-Specific Builders?

While v0.0 provides maximum flexibility with generic specs, domain-specific
builders offer:

1. **Semantic Clarity**: Method names like `.trait()` and `.constraint()`
   express intent better than generic `.spec()`
2. **Type Safety**: Each builder can enforce its own validation rules and
   structure
3. **Discoverability**: IDE autocomplete shows relevant methods for each domain
4. **Best Practices**: Builders guide users toward proven prompt patterns

### Why "SpecBuilderFor" Naming?

The `SpecBuilderFor*` pattern:

1. **Clear Inheritance**: Shows these extend the base `SpecBuilder` concept
2. **Namespace Organization**: Groups related builders together in imports
3. **Extensibility**: Easy to add new domains following the same pattern
4. **Type System**: TypeScript can infer relationships between builders

## Core Architecture

### Builder Hierarchy

```typescript
// Base (from v0.0)
class SpecBuilder {
  spec(value: string): SpecBuilder;
  specs(name: string, fn: (builder: SpecBuilder) => SpecBuilder): SpecBuilder;
  getSpecs(): Spec[];
}

// Domain-specific (v0.1)
class SpecBuilderForPersona extends SpecBuilder {
  description(value: string): SpecBuilderForPersona;
  trait(value: string): SpecBuilderForPersona;
  traits(...values: string[]): SpecBuilderForPersona;
}

class SpecBuilderForConstraints extends SpecBuilder {
  constraint(value: string): SpecBuilderForConstraints;
  constraints(...values: string[]): SpecBuilderForConstraints;
  category(
    name: string,
    fn: (builder: SpecBuilderForConstraints) => SpecBuilderForConstraints,
  ): SpecBuilderForConstraints;
}

class SpecBuilderForBehaviors extends SpecBuilder {
  behavior(value: string): SpecBuilderForBehaviors;
  behaviors(...values: string[]): SpecBuilderForBehaviors;
  when(
    condition: string,
    fn: (builder: SpecBuilderForBehaviors) => SpecBuilderForBehaviors,
  ): SpecBuilderForBehaviors;
}
```

### Integration with v0.0

Domain-specific builders integrate seamlessly with the base architecture:

```typescript
const assistant = boltFoundryClient.createAssistant("helper", (b) => {
  return b
    .specs("persona", (s) =>
      new SpecBuilderForPersona()
        .description("You are a helpful coding assistant")
        .trait("Patient and thorough")
        .trait("Explains concepts clearly"))
    .specs("constraints", (s) =>
      new SpecBuilderForConstraints()
        .constraint("Never write code with security vulnerabilities")
        .category("style", (c) =>
          c
            .constraint("Use consistent naming conventions")
            .constraint("Prefer functional programming patterns")))
    .specs("behaviors", (s) =>
      new SpecBuilderForBehaviors()
        .behavior("Always test code before presenting it")
        .when("user is beginner", (b) =>
          b
            .behavior("Provide extra explanations")
            .behavior("Use simpler examples")));
});
```

## Implementation Versions

### v0.1.0: SpecBuilderForPersona

**Goal**: Enable structured persona definitions with descriptions and traits

**Implementation**:

```typescript
export class SpecBuilderForPersona extends SpecBuilder {
  description(value: string): SpecBuilderForPersona {
    return this.spec(value) as SpecBuilderForPersona;
  }

  trait(value: string): SpecBuilderForPersona {
    return this.spec(value) as SpecBuilderForPersona;
  }

  traits(...values: string[]): SpecBuilderForPersona {
    let builder: SpecBuilderForPersona = this;
    for (const value of values) {
      builder = builder.trait(value);
    }
    return builder;
  }
}
```

**Testing Focus**:

- Verify inheritance from SpecBuilder
- Test method chaining maintains type
- Validate specs structure matches v0.0 format

### v0.1.1: SpecBuilderForConstraints

**Goal**: Define rules and boundaries with optional categorization

**Implementation**:

```typescript
export class SpecBuilderForConstraints extends SpecBuilder {
  constraint(value: string): SpecBuilderForConstraints {
    return this.spec(value) as SpecBuilderForConstraints;
  }

  constraints(...values: string[]): SpecBuilderForConstraints {
    let builder: SpecBuilderForConstraints = this;
    for (const value of values) {
      builder = builder.constraint(value);
    }
    return builder;
  }

  category(
    name: string,
    fn: (builder: SpecBuilderForConstraints) => SpecBuilderForConstraints,
  ): SpecBuilderForConstraints {
    return this.specs(name, fn as any) as SpecBuilderForConstraints;
  }
}
```

**Testing Focus**:

- Category nesting creates proper spec structure
- Multiple constraints maintain order
- Type safety through inheritance chain

### v0.1.2: SpecBuilderForBehaviors

**Goal**: Express expected actions and conditional behaviors

**Implementation**:

```typescript
export class SpecBuilderForBehaviors extends SpecBuilder {
  behavior(value: string): SpecBuilderForBehaviors {
    return this.spec(value) as SpecBuilderForBehaviors;
  }

  behaviors(...values: string[]): SpecBuilderForBehaviors {
    let builder: SpecBuilderForBehaviors = this;
    for (const value of values) {
      builder = builder.behavior(value);
    }
    return builder;
  }

  when(
    condition: string,
    fn: (builder: SpecBuilderForBehaviors) => SpecBuilderForBehaviors,
  ): SpecBuilderForBehaviors {
    return this.specs(
      `when ${condition}`,
      fn as any,
    ) as SpecBuilderForBehaviors;
  }
}
```

**Testing Focus**:

- Conditional behaviors create named groups
- Nested when clauses work correctly
- Maintains v0.0 spec compatibility

### v0.1.3: Full Integration

**Goal**: Ensure all builders work together with type safety

**Key Tasks**:

- Update `AssistantSpec` to accept domain-specific builders
- Add type overloads for `.specs()` method to maintain type safety
- Create comprehensive examples showing all builders together
- Performance testing with complex nested structures

## Usage Examples

### Simple Persona

```typescript
const persona = new SpecBuilderForPersona()
  .description("You are a friendly teacher")
  .trait("Patient")
  .trait("Encouraging")
  .trait("Clear communicator");
```

### Categorized Constraints

```typescript
const constraints = new SpecBuilderForConstraints()
  .constraint("Always be respectful")
  .category("technical", (c) =>
    c
      .constraint("Use TypeScript")
      .constraint("Follow SOLID principles"))
  .category("communication", (c) =>
    c
      .constraint("Keep explanations concise")
      .constraint("Use examples when helpful"));
```

### Conditional Behaviors

```typescript
const behaviors = new SpecBuilderForBehaviors()
  .behavior("Start with a greeting")
  .when("code review requested", (b) =>
    b
      .behavior("Check for common issues first")
      .behavior("Suggest improvements gently")
      .behavior("Highlight what works well"))
  .when("debugging help needed", (b) =>
    b
      .behavior("Ask for error messages")
      .behavior("Request minimal reproduction"));
```

## Testing Strategy

### Unit Tests

Each builder needs comprehensive tests:

```typescript
Deno.test("SpecBuilderForPersona - maintains spec structure", () => {
  const builder = new SpecBuilderForPersona()
    .description("Test description")
    .trait("Test trait");

  const specs = builder.getSpecs();
  assertEquals(specs.length, 2);
  assertEquals(specs[0].value, "Test description");
  assertEquals(specs[1].value, "Test trait");
});

Deno.test("SpecBuilderForConstraints - categories create named groups", () => {
  const builder = new SpecBuilderForConstraints()
    .category("security", (c) =>
      c
        .constraint("No eval()")
        .constraint("Sanitize inputs"));

  const specs = builder.getSpecs();
  assertEquals(specs.length, 1);
  assertEquals(specs[0].name, "security");
  assertEquals((specs[0].value as Spec[]).length, 2);
});
```

### Integration Tests

Test builders working together:

```typescript
Deno.test("All builders integrate with createAssistant", () => {
  const assistant = boltFoundryClient.createAssistant("test", (b) => {
    return b
      .specs("persona", () =>
        new SpecBuilderForPersona()
          .description("Test assistant")
          .trait("Helpful"))
      .specs("constraints", () =>
        new SpecBuilderForConstraints()
          .constraint("Be safe"))
      .specs("behaviors", () =>
        new SpecBuilderForBehaviors()
          .behavior("Be proactive"));
  });

  const result = assistant.render({ model: "gpt-4" });
  assert(result.messages[0].content.includes("Test assistant"));
  assert(result.messages[0].content.includes("Helpful"));
  assert(result.messages[0].content.includes("Be safe"));
  assert(result.messages[0].content.includes("Be proactive"));
});
```

## Success Criteria

### Technical Success

- All domain-specific builders extend SpecBuilder correctly
- Type safety maintained through inheritance chain
- No breaking changes to v0.0 API
- Performance remains fast (< 1ms for typical builds)

### Developer Experience

- IntelliSense shows appropriate methods for each builder
- Clear error messages for invalid usage
- Seamless integration between generic and specific builders
- Documentation with practical examples

### Adoption Metrics

- 50+ developers upgrade from v0.0 to v0.1
- Positive feedback on domain-specific methods
- Examples shared in community showing real usage
- No regression in v0.0 functionality

## Migration Path

Users can adopt v0.1 incrementally:

```typescript
// v0.0 style (still works)
.specs("persona", (s) => s
  .spec("You are helpful")
  .spec("Patient")
)

// v0.1 style (new option)
.specs("persona", () => new SpecBuilderForPersona()
  .description("You are helpful")
  .trait("Patient")
)

// Mixed usage (supported)
.specs("custom", (s) => s
  .spec("Generic spec")
  .specs("persona", () => new SpecBuilderForPersona()
    .trait("Specific trait")
  )
)
```

## Future Considerations

### v0.2 Possibilities

- `SpecBuilderForExamples`: Few-shot learning patterns
- `SpecBuilderForTools`: Function/tool definitions
- `SpecBuilderForMemory`: Context window management

### Extension Points

- Custom builders can be created by users
- Plugin system for third-party builders
- Builder composition and mixins

## Risks and Mitigation

### Risk: Over-Specialization

**Mitigation**: Keep builders focused on common patterns. Unusual cases should
use generic specs.

### Risk: Type Complexity

**Mitigation**: Extensive TypeScript tests. Clear examples. Consider simplified
types for common cases.

### Risk: Breaking Changes

**Mitigation**: All v0.0 code must work unchanged. New features are purely
additive.

## Next Steps

1. Implement SpecBuilderForPersona with tests
2. Add remaining builders incrementally
3. Update documentation with examples
4. Release v0.1.0-alpha for feedback
5. Iterate based on user experience
