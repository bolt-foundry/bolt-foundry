# Bolt Foundry SDK v0.1 - Simplified Card System

## Overview

Version 0.1 simplifies the v0.0 spec foundation into a card-based system that
provides a clean, flexible API for creating structured LLM specifications. The
focus is on simplicity and composability without prescriptive structure.

## Technical Approach

### Simplified Card API

The card system provides:

1. **Single Entry Point**: One `createCard()` function for all card creation
2. **Flexible Structure**: Organize specs however makes sense for your use case  
3. **Sample System**: Rate examples from -3 to +3 to guide behavior
4. **No Prescribed Types**: Cards are just named collections of specs

### Why This Approach?

1. **Simplicity**: One way to create cards reduces cognitive load
2. **Flexibility**: No forced structure means cards can adapt to any use case
3. **Example-Driven**: Samples with ratings are more intuitive than rules
4. **Future-Proof**: Simple foundation can be extended without breaking changes

## Core Architecture

### API Design

```typescript
// Create any card with the same function
const card = createCard("name", (builder) => 
  builder.specs("category", (s) => 
    s.spec("item", {
      samples: (sam) => 
        sam.sample("good example", 3)
           .sample("bad example", -3)
    })
  )
);

// Card structure
interface Card {
  name: string;
  specs: Spec[];
}

// Samples with ratings
interface Sample {
  text: string;
  rating: number; // -3 to +3
}
```

### Rating System

The -3 to +3 rating system provides intuitive guidance:

- **+3**: Excellent example of desired behavior
- **+2**: Good example
- **+1**: Acceptable example  
- **0**: Neutral
- **-1**: Slightly undesirable
- **-2**: Poor example
- **-3**: Terrible example to avoid

This maps efficiently to 3 bits of storage while providing clear semantic meaning.

## Usage Examples

### Basic Card

```typescript
const assistant = createCard("helpful-assistant", (b) =>
  b.specs("personality", (p) =>
    p.spec("friendly and professional")
     .spec("patient with questions")
  )
);
```

### Card with Samples

```typescript
const codeReviewer = createCard("code-reviewer", (b) =>
  b.specs("feedback-style", (f) =>
    f.spec("constructive criticism", {
      samples: (s) =>
        s.sample("Consider using const here for immutability", 3)
         .sample("This code is wrong", -3)
         .sample("You might want to refactor this function", 2)
         .sample("Bad variable naming", -2)
    })
  )
);
```

### Complex Nested Structure

```typescript
const dataAnalyst = createCard("data-analyst", (b) =>
  b.specs("skills", (s) =>
    s.specs("technical", (t) =>
      t.spec("Python proficiency", {
        samples: (sam) =>
          sam.sample("Uses pandas efficiently for data manipulation", 3)
             .sample("Writes loops instead of vectorized operations", -2)
      })
      .spec("SQL expertise")
    )
    .specs("communication", (c) =>
      c.spec("explains findings clearly")
       .spec("creates meaningful visualizations")
    )
  )
);
```

## Implementation Details

### Immutable Builders

Following the pattern from bfDb, all builders are immutable:

```typescript
const base = createCard("base", (b) => b.specs("a", (a) => a.spec("1")));
const extended = createCard("extended", (b) => 
  b.specs("a", (a) => a.spec("1"))
   .specs("b", (b) => b.spec("2"))
);
// base is unchanged
```

### Type Safety

Full TypeScript support with type inference:

```typescript
// TypeScript knows the structure
const card = createCard("typed", (b) =>
  b.specs("section", (s) => s.spec("value"))
);

// Type error if used incorrectly
card.specs[0].notAProperty; // Error: Property 'notAProperty' does not exist
```

## Testing Strategy

### Unit Tests

Test individual components:

```typescript
Deno.test("createCard - creates named card", () => {
  const card = createCard("test", (b) => b);
  assertEquals(card.name, "test");
  assertEquals(card.specs, []);
});

Deno.test("samples - ratings in valid range", () => {
  const card = createCard("test", (b) =>
    b.specs("s", (s) => s.spec("x", {
      samples: (sam) => sam.sample("text", 3)
    }))
  );
  
  const sample = card.specs[0].value[0].samples[0];
  assertEquals(sample.rating, 3);
  assert(sample.rating >= -3 && sample.rating <= 3);
});
```

### Integration Tests

Test real-world usage patterns:

```typescript
Deno.test("Pokemon trainer card example", () => {
  const ash = createCard("ash-ketchum", (b) =>
    b.specs("traits", (t) =>
      t.spec("determined", {
        samples: (s) =>
          s.sample("Never gives up against legendary Pokemon", 3)
           .sample("Quits after one loss", -3)
      })
    )
  );
  
  assertEquals(ash.name, "ash-ketchum");
  assertEquals(ash.specs[0].name, "traits");
});
```

## Migration from v0.0

The new API is simpler but conceptually similar:

```typescript
// v0.0 style
const spec = new SpecBuilder()
  .spec("value")
  .specs("group", (s) => s.spec("nested"));

// v0.1 style  
const card = createCard("name", (b) =>
  b.specs("group", (s) => s.spec("nested"))
);
```

## Success Metrics

- **Adoption**: 100+ developers using within first month
- **Simplicity**: New users creating first card in < 5 minutes
- **Satisfaction**: Positive feedback on API simplicity
- **Performance**: Card creation < 1ms for typical use cases

## Future Considerations

### Potential Extensions

- **Serialization**: JSON/YAML import/export
- **Validation**: Runtime validation of card structure
- **Composition**: Combining multiple cards
- **Templates**: Pre-built cards for common use cases

### Ecosystem Growth

- **Card Registry**: Share cards between projects
- **Card Testing**: Frameworks for validating card behavior
- **Card Analytics**: Track which cards perform best
- **Card Documentation**: Auto-generate docs from cards

## Summary

Version 0.1 delivers a simple, flexible card system that makes structured LLM
specifications accessible to all developers. By focusing on a single API with
example-driven development, we lower the barrier to entry while maintaining the
power to build complex, nuanced AI behaviors.