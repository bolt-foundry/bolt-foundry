# Updated Plan: import.meta.env Injection Implementation

**Date:** 2025-08-01\
**Status:** Planning\
**Priority:** High

## Problem Statement

The current configuration simplification plan assumes `import.meta.env` works
natively, but:

- Deno doesn't automatically inject `.env` files into `import.meta.env`
- Vite only handles `import.meta.env` for client builds, not SSR
- We need a universal solution that works in all environments

## Solution: injectEnvironmentVariable Method

### Core Design

```typescript
// packages/env/inject.ts
export function injectEnvironmentVariable(importMeta: ImportMeta): void {
  // Only inject if not already present
  if (!importMeta.env || Object.keys(importMeta.env).length === 0) {
    importMeta.env = loadEnvironmentVariables();
  }
}

function loadEnvironmentVariables(): Record<string, string> {
  const env: Record<string, string> = {};

  // 1. Start with Deno.env (system environment variables)
  if (typeof Deno !== "undefined") {
    for (const [key, value] of Object.entries(Deno.env.toObject())) {
      env[key] = value;
    }
  }

  // 2. Load .env files in order of precedence
  const isServer = typeof window === "undefined";
  const files = isServer
    ? [".env.server", ".env.client", ".env.local"]
    : [".env.client", ".env.local"]; // Client never sees .env.server

  for (const file of files) {
    try {
      const content = readFileSync(file); // Sync for import-time
      const parsed = parseEnvFile(content);
      Object.assign(env, parsed); // Later files override earlier ones
    } catch {
      // File doesn't exist, continue
    }
  }

  // 3. Add runtime flags
  env.DEV = String(!env.PROD);
  env.PROD = String(env.BF_ENV === "production");
  env.SSR = String(isServer);
  env.MODE = env.BF_ENV || "development";

  return env;
}
```

### Usage Pattern

#### Server-Side (Deno)

```typescript
// At the top of every server entry point
import { injectEnvironmentVariable } from "@bfmono/packages/env/inject.ts";
injectEnvironmentVariable(import.meta);

// Then use normally
const apiKey = import.meta.env.OPENAI_API_KEY;
```

#### Client-Side (Vite)

```typescript
// vite.config.ts
import { boltFoundryEnvPlugin } from "@bfmono/packages/env/vite-plugin.ts";

export default {
  plugins: [
    boltFoundryEnvPlugin({
      clientEnvFile: ".env.client",
      localEnvFile: ".env.local",
    }),
  ],
};
```

```typescript
// packages/env/vite-plugin.ts
export function boltFoundryEnvPlugin(options: EnvPluginOptions) {
  return {
    name: "bolt-foundry-env",

    // Transform import.meta.env references at build time
    transform(code: string, id: string) {
      if (!code.includes("import.meta.env")) return;

      // Load client-safe env vars
      const clientVars = loadClientEnvironment(options);

      // Replace import.meta.env.KEY with actual values
      return transformImportMetaEnv(code, clientVars);
    },

    // For dev server
    configureServer(server) {
      // Inject env vars for HMR
      server.middlewares.use((req, res, next) => {
        if (req.url === "/@vite/env") {
          const clientVars = loadClientEnvironment(options);
          res.end(`window.__VITE_ENV__ = ${JSON.stringify(clientVars)}`);
        }
        next();
      });
    },
  };
}
```

### TypeScript Support

```typescript
// packages/env/types.ts
declare global {
  interface ImportMeta {
    env: ImportMetaEnv;
  }

  interface ImportMetaEnv extends Record<string, string> {
    // Base properties always present
    MODE: string;
    BASE_URL: string;
    PROD: string;
    DEV: string;
    SSR: string;

    // Generated from .env.example files
    // (auto-generated by bft secrets sync)
  }
}
```

### Integration Points

#### 1. Server Applications

```typescript
// apps/boltfoundry-com/server.tsx
import { injectEnvironmentVariable } from "@bfmono/packages/env/inject.ts";
injectEnvironmentVariable(import.meta);

// Now import.meta.env is available
const port = import.meta.env.WEB_PORT || "8000";
```

#### 2. CLI Tools

```typescript
// apps/aibff/main.ts
import { injectEnvironmentVariable } from "@bfmono/packages/env/inject.ts";
injectEnvironmentVariable(import.meta);

// Environment variables available throughout the app
```

#### 3. Test Environment

```typescript
// In test setup files
import { injectEnvironmentVariable } from "@bfmono/packages/env/inject.ts";
injectEnvironmentVariable(import.meta);

// Override for tests
import.meta.env.BF_ENV = "test";
```

### Production Container Boot

```typescript
// packages/env/production-boot.ts
export async function initializeProductionEnvironment() {
  // 1. Try to load from cache
  const cacheFile = "/data/production-secrets.env";

  if (await shouldRefreshSecrets(cacheFile)) {
    // 2. Fetch from 1Password
    const secrets = await fetchFrom1Password();

    // 3. Write to cache
    await writeEnvFile(cacheFile, secrets);
  }

  // 4. Load into process environment
  const cached = await readEnvFile(cacheFile);
  for (const [key, value] of Object.entries(cached)) {
    Deno.env.set(key, value);
  }

  // 5. Now injectEnvironmentVariable will pick them up
  injectEnvironmentVariable(import.meta);
}
```

### Migration Strategy

#### Phase 1: Add Injection Infrastructure

1. Create `packages/env/inject.ts` with `injectEnvironmentVariable`
2. Create `packages/env/vite-plugin.ts` for client builds
3. Add TypeScript declarations
4. Test with a single app

#### Phase 2: Update Applications

1. Add `injectEnvironmentVariable(import.meta)` to all entry points
2. Update Vite configs to use the plugin
3. Verify both client and server environments work

#### Phase 3: Migrate from getConfigurationVariable

1. Update code to use `import.meta.env.KEY`
2. Remove `getConfigurationVariable` calls
3. Keep compatibility layer during transition

### Key Benefits

1. **Universal API**: Same `import.meta.env` interface everywhere
2. **Explicit Injection**: Clear where environment is loaded
3. **Type Safety**: Full TypeScript support
4. **Client/Server Separation**: Automatic filtering of server-only vars
5. **Testing Friendly**: Easy to mock/override in tests
6. **Production Ready**: Works with 1Password integration

### Example Implementation

```typescript
// Complete example for packages/env/inject.ts
import { readFileSync } from "node:fs";

const ENV_CACHE = new WeakMap<ImportMeta, Record<string, string>>();

export function injectEnvironmentVariable(importMeta: ImportMeta): void {
  // Check cache first
  if (ENV_CACHE.has(importMeta)) {
    importMeta.env = ENV_CACHE.get(importMeta)!;
    return;
  }

  const env = loadEnvironmentVariables();
  ENV_CACHE.set(importMeta, env);
  importMeta.env = env;
}

function loadEnvironmentVariables(): Record<string, string> {
  const env: Record<string, string> = {};
  const isServer = typeof window === "undefined";

  // System environment variables (highest priority)
  if (typeof Deno !== "undefined") {
    Object.assign(env, Deno.env.toObject());
  } else if (typeof process !== "undefined") {
    Object.assign(env, process.env);
  }

  // Load .env files (lower priority, won't override system env)
  const envFiles = isServer
    ? [".env.client", ".env.server", ".env.local"]
    : [".env.client", ".env.local"];

  for (const file of envFiles) {
    try {
      const content = typeof Deno !== "undefined"
        ? Deno.readTextFileSync(file)
        : readFileSync(file, "utf-8");

      const parsed = parseEnvFile(content);

      // Only set if not already defined (system env takes precedence)
      for (const [key, value] of Object.entries(parsed)) {
        if (!(key in env)) {
          env[key] = value;
        }
      }
    } catch {
      // File doesn't exist or can't be read
    }
  }

  // Set computed properties
  env.SSR = String(isServer);
  env.DEV = env.BF_ENV !== "production" ? "true" : "false";
  env.PROD = env.BF_ENV === "production" ? "true" : "false";
  env.MODE = env.BF_ENV || "development";

  return env;
}

function parseEnvFile(content: string): Record<string, string> {
  const result: Record<string, string> = {};

  for (const line of content.split("\n")) {
    const trimmed = line.trim();

    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith("#")) continue;

    // Parse KEY=VALUE
    const separatorIndex = trimmed.indexOf("=");
    if (separatorIndex === -1) continue;

    const key = trimmed.slice(0, separatorIndex).trim();
    let value = trimmed.slice(separatorIndex + 1).trim();

    // Remove quotes if present
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }

    result[key] = value;
  }

  return result;
}
```

### Testing Approach

```typescript
// packages/env/__tests__/inject.test.ts
import { assertEquals } from "@std/assert";
import { injectEnvironmentVariable } from "../inject.ts";

Deno.test("injectEnvironmentVariable loads system env", () => {
  const mockImportMeta = { url: "file:///test.ts" } as ImportMeta;

  Deno.env.set("TEST_VAR", "test_value");
  injectEnvironmentVariable(mockImportMeta);

  assertEquals(mockImportMeta.env.TEST_VAR, "test_value");
});

Deno.test("injectEnvironmentVariable sets SSR correctly", () => {
  const mockImportMeta = { url: "file:///test.ts" } as ImportMeta;

  injectEnvironmentVariable(mockImportMeta);

  // In Deno (server), SSR should be "true"
  assertEquals(mockImportMeta.env.SSR, "true");
});
```

## Summary

This updated plan provides a practical solution for `import.meta.env` that:

1. Works universally across client and server
2. Requires explicit injection (no magic)
3. Maintains security boundaries
4. Integrates with existing infrastructure
5. Provides a clear migration path

The `injectEnvironmentVariable` method becomes the single entry point for
environment configuration, replacing the complex multi-command system with a
simple, explicit approach.
