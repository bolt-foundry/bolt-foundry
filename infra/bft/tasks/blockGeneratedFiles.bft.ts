#!/usr/bin/env -S deno run --allow-read --allow-env

/**
 * BFT task for blocking edits to generated files
 *
 * This task prevents accidental edits to auto-generated files, build outputs,
 * vendor dependencies, and other files that should not be manually modified.
 */

import { ui } from "@bfmono/packages/tui/tui.ts";
import { getLogger } from "@bfmono/packages/logger/logger.ts";
import type { TaskDefinition } from "../bft.ts";

const logger = getLogger(import.meta);

interface HookContext {
  session_id: string;
  transcript_path: string;
  tool_name: string;
  tool_input: Record<string, unknown>;
}

interface HookResponse {
  decision: "block" | "approve" | undefined;
  reason?: string;
}

// Patterns for directories that contain generated files
const BLOCKED_DIRECTORY_PATTERNS = [
  "**/__generated__/**",
  "**/__isograph/**",
  "**/build/**",
  "**/dist/**",
  "**/vendor/**",
  "**/node_modules/**",
  "**/thirdParty/**",
  "**/tmp/**",
  "**/.sl/**",
  "static/build/**",
];

// File patterns that should be blocked
const BLOCKED_FILE_PATTERNS = [
  "**/*.generated.*",
  "**/*.min.js",
  "**/*.map",
  "**/*.lock",
  "**/*.sqlite-shm",
  "**/*.sqlite-wal",
  "**/test-db-test-*.sqlite*",
  "**/generated-icon.png",
];

// Auto-generated file markers to check in file content
const GENERATED_MARKERS = [
  "@generated",
  "This file is auto-generated",
  "DO NOT EDIT",
  "Generated by",
  "// @generated by",
];

async function main() {
  try {
    const input = await readStdin();
    const context: HookContext = JSON.parse(input);

    const filePath = getFilePathFromContext(context);
    if (!filePath) {
      // No file path found, allow the operation
      Deno.exit(0);
    }

    // Check if this is a file editing operation
    if (!isFileEditOperation(context.tool_name)) {
      // Not a file edit operation, allow it
      Deno.exit(0);
    }

    // Check if the file should be blocked
    const blockReason = await shouldBlockFile(filePath);
    if (blockReason) {
      const response: HookResponse = {
        decision: "block",
        reason: blockReason,
      };
      ui.output(JSON.stringify(response));
      Deno.exit(2);
    }

    // File is safe to edit, allow the operation
    Deno.exit(0);
  } catch (error) {
    ui.error(`Block generated files hook error: ${(error as Error).message}`);
    Deno.exit(1);
  }
}

async function readStdin(): Promise<string> {
  const decoder = new TextDecoder();
  const chunks: Array<Uint8Array> = [];

  for await (const chunk of Deno.stdin.readable) {
    chunks.push(chunk);
  }

  const combined = new Uint8Array(
    chunks.reduce((acc, chunk) => acc + chunk.length, 0),
  );
  let offset = 0;
  for (const chunk of chunks) {
    combined.set(chunk, offset);
    offset += chunk.length;
  }

  return decoder.decode(combined);
}

function getFilePathFromContext(context: HookContext): string | null {
  const { tool_name, tool_input } = context;

  switch (tool_name) {
    case "Edit":
    case "MultiEdit":
    case "Write":
      return tool_input.file_path as string || null;
    default:
      return null;
  }
}

function isFileEditOperation(toolName: string): boolean {
  return ["Edit", "MultiEdit", "Write"].includes(toolName);
}

async function shouldBlockFile(filePath: string): Promise<string | null> {
  // Check directory patterns
  for (const pattern of BLOCKED_DIRECTORY_PATTERNS) {
    logger.debug(`Testing pattern '${pattern}' against '${filePath}'`);
    if (matchesPattern(filePath, pattern)) {
      return `Cannot edit files in generated/build directory. File: ${filePath}`;
    }
  }

  // Check file patterns
  for (const pattern of BLOCKED_FILE_PATTERNS) {
    if (matchesPattern(filePath, pattern)) {
      return `Cannot edit generated/build file. File: ${filePath}`;
    }
  }

  // Check file content for generated markers
  try {
    const content = await Deno.readTextFile(filePath);
    const firstLines = content.split("\n").slice(0, 10).join("\n");

    for (const marker of GENERATED_MARKERS) {
      if (firstLines.includes(marker)) {
        return `Cannot edit auto-generated file (contains "${marker}"). File: ${filePath}`;
      }
    }
  } catch (_error) {
    // If we can't read the file, it might not exist yet (for Write operations)
    // In this case, allow the operation unless the path itself matches a blocked pattern
  }

  return null;
}

function matchesPattern(filePath: string, pattern: string): boolean {
  // Normalize the file path (remove leading ./ if present)
  const normalizedPath = filePath.replace(/^\.\//, "");

  // For simple directory patterns like **/node_modules/**, just check if the path contains the directory
  if (pattern.startsWith("**/") && pattern.endsWith("/**")) {
    const dirName = pattern.slice(3, -3); // Remove **/ and /**
    const matches = normalizedPath.includes(`/${dirName}/`) ||
      normalizedPath.startsWith(`${dirName}/`);
    logger.debug(
      `Simple pattern '${pattern}' -> Directory: '${dirName}' -> FilePath: '${normalizedPath}' -> Match: ${matches}`,
    );
    return matches;
  }

  // For file extension patterns like **/*.min.js, check if the path ends with the extension
  if (pattern.startsWith("**/") && pattern.includes("*.")) {
    const suffix = pattern.slice(3); // Remove **/
    const extension = suffix.replace("*", ""); // Remove * to get the actual extension
    const matches = normalizedPath.includes("/") &&
      normalizedPath.endsWith(extension);
    logger.debug(
      `Extension pattern '${pattern}' -> Extension: '${extension}' -> FilePath: '${normalizedPath}' -> Match: ${matches}`,
    );
    return matches;
  }

  // For exact patterns without wildcards
  if (!pattern.includes("*")) {
    const matches = normalizedPath === pattern;
    logger.debug(
      `Exact pattern '${pattern}' -> FilePath: '${normalizedPath}' -> Match: ${matches}`,
    );
    return matches;
  }

  logger.debug(
    `Unhandled pattern '${pattern}' -> FilePath: '${normalizedPath}' -> Match: false`,
  );
  return false;
}

// Export the task definition for autodiscovery
export const bftDefinition = {
  description: "Block edits to generated files (Claude Code hook)",
  fn: async (): Promise<number> => {
    await main();
    return 0;
  },
} satisfies TaskDefinition;

if (import.meta.main) {
  main();
}
