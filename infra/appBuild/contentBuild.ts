#!/usr/bin/env -S deno run -A

import { getConfigurationVariable } from "@bolt-foundry/get-configuration-var";
import { ensureDir, exists } from "@std/fs";
import { basename, dirname, extname, join } from "@std/path";
import { getLogger } from "packages/logger/logger.ts";
import { compile } from "@mdx-js/mdx";

const logger = getLogger(import.meta);

async function processDocsFiles() {
  const docsDir = getConfigurationVariable("DOCS_DIR") || "docs";
  const buildDir = getConfigurationVariable("BUILD_DIR") || "static/build";
  const generatedDir = getConfigurationVariable("GENERATED_DIR") ||
    "apps/boltFoundry/__generated__";

  // Ensure directories exist
  const docsOutputDir = join(buildDir, "docs");
  await ensureDir(docsOutputDir);
  await ensureDir(generatedDir);

  // Check if docs directory exists
  if (!await exists(docsDir)) {
    logger.info("No docs directory found, skipping docs processing");
    return;
  }

  // Collect all MDX files
  const mdxFiles: { slug: string; path: string }[] = [];

  // Walk through docs directory
  for await (const entry of Deno.readDir(docsDir)) {
    if (
      entry.isFile &&
      (entry.name.endsWith(".mdx") || entry.name.endsWith(".md"))
    ) {
      const slug = basename(entry.name, extname(entry.name));
      mdxFiles.push({ slug, path: join(docsDir, entry.name) });
    }
  }

  // Process each MDX file
  for (const { slug, path } of mdxFiles) {
    await processMdxFile(path, slug, docsOutputDir);
  }

  // Generate import map
  await generateImportMap(mdxFiles, generatedDir);
}

async function processMdxFile(
  sourcePath: string,
  slug: string,
  outputDir: string,
) {
  try {
    const content = await Deno.readTextFile(sourcePath);

    // Compile MDX to JS as a complete program
    const compiled = await compile(content, {
      outputFormat: "program",
      development: false,
    });

    // The compiled output is already a complete ES module
    const moduleContent = String(compiled);

    // Save as .js file so it can be imported
    const destPath = join(outputDir, `${slug}.js`);
    await ensureDir(dirname(destPath));

    logger.info(`Compiling ${sourcePath} -> ${destPath}`);

    await Deno.writeTextFile(destPath, moduleContent);
  } catch (error) {
    logger.error(`Error compiling ${sourcePath}: ${error}`);
    throw error;
  }
}

async function generateImportMap(
  mdxFiles: { slug: string; path: string }[],
  generatedDir: string,
) {
  const importMapPath = join(generatedDir, "docsImportMap.ts");

  // Generate the import map file content with lazy loading
  const content = `// This file is auto-generated by contentBuild.ts
// DO NOT EDIT MANUALLY

import type { ComponentType } from "react";

// Map of available slugs for runtime checking
export const availableDocs = new Set([
${mdxFiles.map(({ slug }) => `  "${slug}",`).join("\n")}
] as const);

// Derive the type from the Set values
export type DocSlug = typeof availableDocs extends Set<infer T> ? T : never;

// Type-safe helper to check if a slug is valid
export function isValidDocSlug(slug: string): slug is DocSlug {
  return availableDocs.has(slug as DocSlug);
}

// Lazy loader for documentation components
export async function loadDocComponent(slug: string): Promise<ComponentType | null> {
  if (!isValidDocSlug(slug)) {
    return null;
  }
  
  try {
    const module = await import(\`/static/build/docs/\${slug}.js\`);
    return module.default || null;
  } catch (error) {
    console.error(\`Failed to load doc component \${slug}:\`, error);
    return null;
  }
}
`;

  logger.info(`Generating import map at ${importMapPath}`);
  await Deno.writeTextFile(importMapPath, content);
}

if (import.meta.main) {
  logger.info("Starting content build process");
  try {
    await processDocsFiles();
    logger.info("Content build process complete");
  } catch (error) {
    logger.error("Build failed:", error);
    Deno.exit(1);
  }
}
