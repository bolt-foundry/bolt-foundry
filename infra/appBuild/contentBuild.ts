#!/usr/bin/env -S deno run -A

import { getConfigurationVariable } from "@bolt-foundry/get-configuration-var";
import { ensureDir, exists } from "@std/fs";
import { basename, dirname, extname, join } from "@std/path";
import { getLogger } from "packages/logger/logger.ts";
import { compile } from "@mdx-js/mdx";

const logger = getLogger(import.meta);

async function processDocsFiles() {
  const docsDir = getConfigurationVariable("DOCS_DIR") || "docs";
  const buildDir = getConfigurationVariable("BUILD_DIR") || "build";
  const generatedDir = getConfigurationVariable("GENERATED_DIR") ||
    "apps/boltFoundry/__generated__";

  // Ensure directories exist
  await ensureDir(join(buildDir, "docs"));
  await ensureDir(generatedDir);

  // Check if docs directory exists
  if (!await exists(docsDir)) {
    logger.info("No docs directory found, skipping docs processing");
    return;
  }

  // Collect all MDX files
  const mdxFiles: { slug: string; path: string }[] = [];

  // Walk through docs directory
  for await (const entry of Deno.readDir(docsDir)) {
    if (
      entry.isFile &&
      (entry.name.endsWith(".mdx") || entry.name.endsWith(".md"))
    ) {
      const slug = basename(entry.name, extname(entry.name));
      mdxFiles.push({ slug, path: join(docsDir, entry.name) });
    }
  }

  // Process each MDX file
  for (const { slug, path } of mdxFiles) {
    await processMdxFile(path, slug, buildDir);
  }

  // Generate import map
  await generateImportMap(mdxFiles, generatedDir);
}

async function processMdxFile(
  sourcePath: string,
  slug: string,
  buildDir: string,
) {
  try {
    const content = await Deno.readTextFile(sourcePath);

    // Compile MDX to JS as a complete program
    const compiled = await compile(content, {
      outputFormat: "program",
      development: false,
    });

    // The compiled output is already a complete ES module
    const moduleContent = String(compiled);

    // Save as .js file so it can be imported
    const destPath = join(buildDir, "docs", `${slug}.js`);
    await ensureDir(dirname(destPath));

    logger.info(`Compiling ${sourcePath} -> ${destPath}`);

    await Deno.writeTextFile(destPath, moduleContent);
  } catch (error) {
    logger.error(`Error compiling ${sourcePath}: ${error}`);
    throw error;
  }
}

async function generateImportMap(
  mdxFiles: { slug: string; path: string }[],
  generatedDir: string,
) {
  const importMapPath = join(generatedDir, "docsImportMap.ts");

  // Generate import statements
  // Import from build directory where files are compiled to JS
  const imports = mdxFiles.map(({ slug }) => {
    // Convert slug to a valid JavaScript identifier
    const identifier = slug.replace(/-/g, "_");
    // Import the compiled JS file
    return `import ${identifier} from "build/docs/${slug}.js";`;
  }).join("\n");

  // Generate component mapping
  const componentMappings = mdxFiles.map(({ slug }) => {
    const identifier = slug.replace(/-/g, "_");
    return `  "${slug}": ${identifier},`;
  }).join("\n");

  // Generate the import map file content
  const content = `// This file is auto-generated by contentBuild.ts
// DO NOT EDIT MANUALLY

${imports}

export const docComponents = {
${componentMappings}
} as const;

export type DocSlug = keyof typeof docComponents;
`;

  logger.info(`Generating import map at ${importMapPath}`);
  await Deno.writeTextFile(importMapPath, content);
}

if (import.meta.main) {
  logger.info("Starting content build process");
  try {
    await processDocsFiles();
    logger.info("Content build process complete");
  } catch (error) {
    logger.error("Build failed:", error);
    Deno.exit(1);
  }
}
