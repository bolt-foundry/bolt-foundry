---
title: "Implementation Plan: queryTargetsConnectionForGraphql"
author: "Replit Assistant"
summary: "Plan for adding a GraphQL connection query method to BfNodeBase"
cta: "Read more"
---

# Implementation Plan: queryTargetsConnectionForGraphql for BfNodeBase

## Overview

This implementation plan outlines the approach for adding a
`queryTargetsConnectionForGraphql` method to the `BfNodeBase` class, with
concrete implementation in the `BfNode` class. This method will enable efficient
GraphQL Relay-style connections for target nodes, providing consistent
cursor-based pagination capabilities across the GraphQL API.

## Background

The Content Foundry platform currently has a `queryTargets` method in
`BfNodeBase` that returns an array of target node instances. While this works
for simple queries, it doesn't support the GraphQL Connection pattern which is
essential for:

1. Standardized pagination with cursor-based navigation
   (first/after/last/before)
2. Consistent edge data structure
3. Connection metadata (count, pageInfo)

Looking at existing code in `packages/bfDb/bfDb.ts`, we can see the
`bfQueryItemsForGraphQLConnection` function which implements proper cursor-based
pagination for GraphQL connections. This approach is more efficient than using
`connectionFromArray` from graphql-relay, as it performs pagination at the
database level rather than in memory.

## Technical Design

### Architecture

The implementation will follow the BfNodeBase/BfNode pattern in the codebase:

1. `BfNodeBase` will define the abstract method with a "not implemented" default
2. `BfNode` will provide the concrete implementation using database-level
   pagination
3. `BfNodeInMemory` will provide an in-memory implementation for testing purposes

### Method Signature in BfNodeBase

```typescript
async queryTargetsConnectionForGraphql<
  TTargetProps extends BfNodeBaseProps,
  TTargetClass extends typeof BfNodeBase<TTargetProps>,
>(
  TargetClass: TTargetClass,
  args: ConnectionArguments,
  props: Partial<TTargetProps> = {},
  edgeProps: Partial<TEdgeProps> = {},
  cache?: BfNodeCache,
): Promise<Connection<ReturnType<InstanceType<TTargetClass>['toGraphql']>>> {
  throw new BfErrorNotImplemented();
}
```

### Implementation Approaches

#### BfNodeInMemory Implementation (In-Memory)

The in-memory implementation uses a simpler approach:

1. Query all target nodes using the existing `queryTargets` method
2. Convert nodes to their GraphQL representation
3. Use `connectionFromArray` to create a GraphQL connection with pagination

This approach is already implemented and works well for testing scenarios, but it's less efficient for large datasets as it loads all records into memory before pagination.

#### BfNode Implementation (Database-Level)

The BfNode implementation will use a more efficient approach:

1. Create edge metadata query with source ID and target class name
2. Create edge props query with any filter conditions 
3. Leverage `bfQueryItemsForGraphQLConnection` to perform pagination at the database level
4. Convert the returned database items to fully instantiated node instances
5. Transform nodes to their GraphQL representation
6. Return a properly structured connection object

This approach is significantly more efficient as it only retrieves the records needed for the current page directly from the database.

## Implementation Details

### BfNodeBase Implementation (Abstract)

The abstract base class will throw a "not implemented" error, consistent with
other abstract methods.

### BfNode Implementation (Concrete)

The implementation in BfNode will leverage `bfQueryItemsForGraphQLConnection` from `bfDb.ts`. Here's the detailed implementation approach:

```typescript
override async queryTargetsConnectionForGraphql<
  TTargetProps extends BfNodeBaseProps,
  TTargetClass extends typeof BfNodeBase<TTargetProps>,
>(
  TargetClass: TTargetClass,
  args: ConnectionArguments,
  props: Partial<TTargetProps> = {},
  edgeProps: Partial<TEdgeProps> = {},
  cache?: BfNodeCache,
): Promise<Connection<ReturnType<InstanceType<TTargetClass>["toGraphql"]>>> {
  logger.debug(
    `queryTargetsConnectionForGraphql: ${this.constructor.name} -> ${TargetClass.name}`,
    { sourceId: this.metadata.bfGid, targetClass: TargetClass.name, args }
  );

  // Build edge metadata query for relationships
  const metadataQuery = {
    bfSid: this.metadata.bfGid,
    bfTClassName: TargetClass.name
  };

  // Build props query from edgeProps if provided
  const propsQuery = Object.keys(edgeProps).length > 0 ? edgeProps : {};

  // Use bfQueryItemsForGraphQLConnection to handle cursor-based pagination efficiently at DB level
  const connection = await bfQueryItemsForGraphQLConnection(
    metadataQuery,
    propsQuery,
    args,
    [] // No explicit bfGids filter needed as we're filtering by bfSid already
  );

  // Once we have the paginated edges from the database, we need to:
  // 1. Get the target IDs from these edges
  // 2. Query for the actual target node instances
  // 3. Convert each node to its GraphQL representation
  // 4. Structure everything in Relay connection format

  // Extract target IDs from the edges
  const targetIds = connection.edges.map(edge => 
    (edge.node.metadata.bfTid as BfGid)
  );

  // Query for target nodes
  const targetNodes = await TargetClass.query(
    this.cv,
    { className: TargetClass.name },
    props,
    targetIds,
    cache
  );

  // Create a map of target nodes by ID for efficient lookup
  const targetNodesMap = new Map(
    targetNodes.map(node => [node.metadata.bfGid, node])
  );

  // Transform the connection to use actual node instances
  const transformedEdges = connection.edges.map(edge => {
    const targetNode = targetNodesMap.get(edge.node.metadata.bfTid);
    if (!targetNode) {
      logger.error(`Target node with ID ${edge.node.metadata.bfTid} not found`);
      return null;
    }
    return {
      cursor: edge.cursor,
      node: targetNode.toGraphql()
    };
  }).filter(edge => edge !== null);

  // Return the connection with transformed edges
  return {
    edges: transformedEdges,
    pageInfo: connection.pageInfo,
    count: connection.count
  };
}
```

This implementation achieves efficient pagination by:

1. Leveraging database-level pagination through `bfQueryItemsForGraphQLConnection`
2. Only querying for the target node instances that are part of the current page
3. Properly structuring the response to match the Relay connection specification

### BfNodeInMemory Implementation (Already completed)

The in-memory implementation is simpler and already completed, using `connectionFromArray` to handle pagination in memory:

```typescript
override async queryTargetsConnectionForGraphql<
  TTargetProps extends BfNodeBaseProps,
  TTargetClass extends typeof BfNodeBase<TTargetProps>,
>(
  TargetClass: TTargetClass,
  args: ConnectionArguments,
  props: Partial<TTargetProps> = {},
  edgeProps: Partial<BfEdgeBaseProps> = {},
  cache?: BfNodeCache,
): Promise<Connection<ReturnType<InstanceType<TTargetClass>["toGraphql"]>>> {
  // Query target nodes using the existing queryTargets method
  const targets = await this.queryTargets(
    TargetClass,
    props,
    edgeProps,
    cache,
  );

  // Convert nodes to their GraphQL representation
  const graphqlNodes = targets.map((node) => node.toGraphql());

  // Use connectionFromArray to create a GraphQL connection
  return connectionFromArray(graphqlNodes, args) as Connection<
    ReturnType<InstanceType<TTargetClass>["toGraphql"]>
  >;
}
```

## Integration with GraphQL Schema

This method will enable GraphQL schema types to define connection fields that
follow the Relay connection specification. Resolvers will be able to call this
method directly to implement connection fields.

## Considerations

1. **Performance**: Using cursor-based pagination at the database level is much
   more efficient than retrieving all results first.

2. **Edge Data**: The connection includes edge metadata, which allows passing
   relationship data between nodes.

3. **Cache Usage**: The implementation should properly use and update the node
   cache to avoid redundant database queries.

4. **Type Safety**: Ensure proper typing for GraphQL connections.

5. **Sorting**: The implementation respects the sortValue field for consistent ordering.

6. **Error Handling**: Proper error handling and logging is included to aid debugging.

## Testing Strategy

1. Test the BfNodeBase implementation to ensure it throws the correct error
2. Test the BfNode implementation with:
   - Different pagination parameters (first, after, last, before)
   - Various numbers of connected nodes
   - Edge cases (empty results, invalid cursors)
   - Cache functionality
3. Integration tests with GraphQL resolvers

## Conclusion

Adding `queryTargetsConnectionForGraphql` to `BfNodeBase` with concrete implementations in both `BfNode` and `BfNodeInMemory` will standardize how
we implement connections in our GraphQL API, making it easier to add pagination
to new and existing queries while maintaining a consistent interface.

The approach leverages existing database-level pagination capabilities for efficiency while maintaining backward compatibility with in-memory implementations for testing.